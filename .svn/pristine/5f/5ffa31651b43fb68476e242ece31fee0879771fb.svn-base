package tw.edu.ntut.csie.game.state;

import java.util.List;
import java.util.Map;
import java.util.Random;

import tw.edu.ntut.csie.game.Game;
import tw.edu.ntut.csie.game.GameObject;
import tw.edu.ntut.csie.game.Pointer;
import tw.edu.ntut.csie.game.R;
import tw.edu.ntut.csie.game.Stair;
import tw.edu.ntut.csie.game.leadingRole;
import tw.edu.ntut.csie.game.core.Audio;
import tw.edu.ntut.csie.game.core.MovingBitmap;
import tw.edu.ntut.csie.game.extend.Animation;
import tw.edu.ntut.csie.game.extend.Integer;
import tw.edu.ntut.csie.game.engine.GameEngine;



public class StateRun extends GameState {
	public static final int DEFAULT_SCORE_DIGITS = 5;
	private MovingBitmap _background;
	private MovingBitmap _android;
	//private MovingBitmap _cloud;
	private MovingBitmap _door;
	private MovingBitmap _message;
	private MovingBitmap _under;
	private leadingRole role;
	private int _rx,_ry;
	private Stair[] _stair;
	//private GameMap gameMap = new GameMap();
	
	private Animation _flower;
	
	private Integer _scores;
	
	private boolean _grab;
	//private int _cx, _cy;
	
	private Audio _music;

	public StateRun(GameEngine engine) {
		super(engine);
	}

	@Override
	public void initialize(Map<String, Object> data) {		
		_under = new MovingBitmap(R.drawable.under);
		_under.setLocation(0, 640-_under.getHeight());
		
		role = new leadingRole();
		role.initialize();
		_rx=role.getX();
		_ry=role.getY();
		
		
		_stair = new Stair[15];
		for(int i=0;i<15;i++){
			_stair[i] = new Stair();
		}
		for(int i=0;i<15;i++){
			_stair[i].setLocation((int)(Math.random()*(376-_stair[i].getWidth()))
								  ,(640-_under.getHeight()-role.getHeight()-5)-(50*(i+1))
								  +(int)(Math.random()*(50-_stair[i].getHeight())));
		}
		
		_background = new MovingBitmap(R.drawable.background);
		
		_message = new MovingBitmap(R.drawable.message, 130, 150);
	
		_android = new MovingBitmap(R.drawable.android_green);
		_android.setLocation(100, 200);
		
		/*_cloud = new MovingBitmap(R.drawable.cloud);
		_cx = 100;
		_cy = 50;
		_cloud.setLocation(_cx, _cy);*/
		
		_door = new MovingBitmap(R.drawable.door);
		_door.setLocation(300, 200);
		
	    _scores = new Integer(DEFAULT_SCORE_DIGITS, 1, 50, 10);
		_flower = new Animation();
		_flower.setLocation(560, 310);
		_flower.addFrame(R.drawable.flower1);
		_flower.addFrame(R.drawable.flower2);
		_flower.addFrame(R.drawable.flower3);
		_flower.addFrame(R.drawable.flower4);
		_flower.addFrame(R.drawable.flower5);
		_flower.setDelay(2);
		
		_music = new Audio(R.raw.ntut);
		_music.setRepeating(true);
		_music.play();
		
		_grab = false;
	}
	
	@Override
	public void move() {
		_flower.move();
		//_cloud.setLocation(_cx, _cy);		
		//role.SetX(_rx);
		/*if(role.getRising()==true && role.getY() < 320){
			
		}else{
			role.move();
		}*/
		
		
		if (role.getRising()) {			// 上升狀態
			if (role.getVelocity() > 0) {
				 _ry -= role.getVelocity();	// 當速度 > 0時，y軸上升(移動velocity個點，velocity的單位為 點/次)
				//velocity--;		// 受重力影響，下次的上升速度降低
				role.subVelocity(4);
			} else {
				role.setRising(false); // 當速度 <= 0，上升終止，下次改為下降
				role.setVelocity(1);	// 下降的初速(velocity)為1
			}
		} else {				// 下降狀態
			if (_ry < role.getFloor()-1-role.getHeight()) {  // 當y座標還沒碰到地板
				_ry += role.getVelocity();	// y軸下降(移動velocity個點，velocity的單位為 點/次)
				//velocity++;		// 受重力影響，下次的下降速度增加
				role.addVelocity(3);
			} else {
				_ry = role.getFloor() - 1;  // 當y座標低於地板，更正為地板上
				role.setRising(true);	// 探底反彈，下次改為上升
				role.setVelocity(role.getInitialVelocity()); // 重設上升初始速度
			}
		}
		role.setLocation(_rx, _ry-role.getHeight());
		
		
	}

	@Override
	public void show() {
		// 呼叫順序為貼圖順序		
		_background.show();
		//_scores.show();
		_flower.show();
		_message.show();
		//_cloud.show();
		_door.show();
		_android.show();
		_under.show();
		for(int i = 0;i<15;i++){
			int hide = (int)(Math.random()*10);
			if(hide==10){
				continue;
			}else{
			_stair[i].show();
			}
		}
		role.show();
	}

	@Override
	public void release() {
		_background.release();
		_scores.release();
		_android.release();
		_flower.release();
		_message.release();
		//_cloud.release();
		_music.release();
		_door.release();
		_under.release();
		role.release();
		for(int i=0;i<15;i++){
			_stair[i].release();
		}
		
		_background = null;
		_scores = null;
		_android = null;
		_flower = null;
		_message = null;
		//_cloud = null;
		_music = null;
		_door = null;	
		_under = null;
		role = null;
		for(int i=0;i<15;i++){
			_stair[i]=null;
		}
	}

	@Override
	public void keyPressed(int keyCode) {
		// TODO Auto-generated method stub
	}

	@Override
	public void keyReleased(int keyCode) {
		// TODO Auto-generated method stub
	}


	public void orientationChanged(float pitch, float azimuth, float roll) {
		/**if(roll > 15 && roll < 60 && _cx > 50)
			_cx -= 2;
		if(roll < -15 && roll > -60 && _cx + _cloud.getWidth() < 500)
			_cx += 2;*/
		//腳色左右移動測試----------------------------
		if(roll > 1 && roll < 90 ){
			if(_rx > 0-role.getWidth()){
				_rx -= (int)((Math.sqrt(roll))*2);
			}else{
				_rx = 376;
			}
		}
		if(roll < -1 && roll > -90 ){
			if(_rx < 376){
				_rx += (int)((Math.sqrt(-(roll)))*2);
			}else{
				_rx = 0-role.getWidth();
			}
		}
		//--------------------------------------
	}

	@Override
	public void accelerationChanged(float dX, float dY, float dZ) {
		// TODO Auto-generated method stub
	}

	@Override
	public boolean pointerPressed(List<Pointer> pointers) {
		_message.setVisible(false);
		if(pointers.size() == 1) {
			int touchX = pointers.get(0).getX();
			int touchY = pointers.get(0).getY();
			if(touchX > _android.getX() && touchX < _android.getX() + _android.getWidth() &&
					touchY > _android.getY() && touchY < _android.getY() + _android.getHeight()) {
				_grab = true;
			} else {
				_grab = false;
			}
		}
		return true;
	}

	@Override
	public boolean pointerMoved(List<Pointer> pointers) {
		if(_grab)
			_android.setLocation(pointers.get(0).getX() - _android.getWidth() / 2, pointers.get(0).getY() - _android.getHeight() / 2);
		int moveX = _android.getX();
		int moveY = _android.getY();
		if(moveX + _android.getWidth() / 2 > _door.getX() && moveX < _door.getX() + _door.getWidth() / 2 &&
				moveY + _android.getHeight() / 2 > _door.getY() && moveY < _door.getY() + _door.getHeight() / 2)
			changeState(Game.OVER_STATE);	
		return false;
	}

	@Override
	public boolean pointerReleased(List<Pointer> pointers) {
		_grab = false;
		return false;
	}

	@Override
	public void pause() {
		_music.pause();
	}

	@Override
	public void resume() {
		_music.resume();
	}
}
